use crate::crypto::aesgcm::{AesGcm256, ConstantTimeEq, Key, Nonce, TAG_LENGTH, Tag};
use crate::crypto::ecc::{MultiRecipientPersistent, retrieve_key, store_key_for_multi_recipients};

use crate::Error;
use crate::layers::traits::{
    InnerWriterTrait, InnerWriterType, LayerFailSafeReader, LayerReader, LayerWriter,
};
use std::convert::TryFrom;
use std::io;
use std::io::{BufReader, Cursor, Read, Seek, SeekFrom, Write};

use crate::config::{ArchiveReaderConfig, ArchiveWriterConfig};
use crate::errors::ConfigError;
use rand::{Rng, SeedableRng};
use rand_chacha::ChaChaRng;
use x25519_dalek::{PublicKey, StaticSecret};

use serde::{Deserialize, Serialize};

use super::traits::InnerReaderTrait;

const CIPHER_BUF_SIZE: u64 = 4096;
// This is the size of the nonce taken as input
const NONCE_SIZE: usize = 8;
const CHUNK_SIZE: u64 = 128 * 1024;

/// Build nonce according to a given state
///
/// `AesGcm` expect a 96 bits nonce.
/// The nonce build as:
/// 1. 8 byte nonce, unique per archive
/// 2. 4 byte counter, unique per chunk and incremental
///
/// Inspired from the construction in TLS or STREAM from "Online
/// Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance"
fn build_nonce(nonce_prefix: [u8; NONCE_SIZE], current_ctr: u32) -> Nonce {
    // This is the Nonce as expected by AesGcm
    let mut nonce = Nonce::default();
    nonce[..NONCE_SIZE].copy_from_slice(&nonce_prefix);
    nonce[NONCE_SIZE..].copy_from_slice(&current_ctr.to_be_bytes());
    nonce
}

// ---------- Config ----------

/// Configuration stored in the header, to be reloaded
#[derive(Serialize, Deserialize)]
pub struct EncryptionPersistentConfig {
    pub multi_recipient: MultiRecipientPersistent,
    nonce: [u8; NONCE_SIZE],
}

/// Specific config for `ArchiveWriter`
pub struct EncryptionConfig {
    /// Public keys with which to encrypt the symmetric encryption key below
    ecc_keys: Vec<PublicKey>,
    /// Symmetric encryption Key
    key: Key,
    /// Symmetric encryption nonce
    nonce: [u8; NONCE_SIZE],
}

impl std::default::Default for EncryptionConfig {
    fn default() -> Self {
        // Use OsRng from crate rand, that uses getrandom() from crate getrandom.
        // getrandom provides implementations for many systems, listed on
        // https://docs.rs/getrandom/0.3.1/getrandom/
        // On Linux it uses `getrandom()` syscall and falls back on `/dev/urandom`.
        // On Windows it uses `RtlGenRandom` API (available since Windows XP/Windows Server 2003).
        //
        // So this seems to be secure, but unfortunately there is no strong
        // warranty that this would stay this way forever.
        // In order to be "better safe than sorry", seed `ChaChaRng` from the
        // bytes generated by `OsRng` in order to build a CSPRNG
        // (Cryptographically Secure PseudoRandom Number Generator).
        // This is actually what `ChaChaRng::from_os_rng()` does:
        // https://github.com/rust-random/rand/blob/340849e53b71da0f15af448d10511c2e62e50ba1/rand_core/src/lib.rs#L555
        // https://github.com/rust-random/rand/blob/340849e53b71da0f15af448d10511c2e62e50ba1/rand_core/src/lib.rs#L571
        // and this function is documented as "secure" in
        // https://docs.rs/rand/latest/rand/trait.SeedableRng.html#method.from_os_rng
        let mut csprng = ChaChaRng::from_os_rng();
        let key = csprng.random::<Key>();
        let nonce = csprng.random::<[u8; NONCE_SIZE]>();
        Self {
            ecc_keys: Vec::new(),
            key,
            nonce,
        }
    }
}

impl EncryptionConfig {
    /// Consistency check
    pub fn check(&self) -> Result<(), ConfigError> {
        if self.ecc_keys.is_empty() {
            Err(ConfigError::EncryptionKeyIsMissing)
        } else {
            Ok(())
        }
    }

    pub fn to_persistent(&self) -> Result<EncryptionPersistentConfig, ConfigError> {
        let mut rng = ChaChaRng::from_os_rng();
        store_key_for_multi_recipients(&self.ecc_keys, &self.key, &mut rng).map_or(
            Err(ConfigError::ECIESComputationError),
            |multi_recipient| {
                Ok(EncryptionPersistentConfig {
                    multi_recipient,
                    nonce: self.nonce,
                })
            },
        )
    }
}

impl ArchiveWriterConfig {
    /// Set public keys to use
    pub fn add_public_keys(&mut self, keys: &[PublicKey]) -> &mut Self {
        self.encrypt.ecc_keys.extend_from_slice(keys);
        self
    }

    /// Return the key used for encryption
    pub const fn encryption_key(&self) -> &Key {
        &self.encrypt.key
    }

    /// Return the nonce used for encryption
    pub const fn encryption_nonce(&self) -> &[u8; NONCE_SIZE] {
        &self.encrypt.nonce
    }
}

/// `FailSafeReader` decryption mode
#[derive(Default, Clone, Copy)]
enum FailSafeReaderDecryptionMode {
    /// Returns only the data that have been authenticated on decryption
    #[default]
    OnlyAuthenticatedData,
    /// Returns all data, even if not authenticated
    DataEvenUnauthenticated,
}

#[derive(Default)]
pub struct EncryptionReaderConfig {
    /// Private key(s) to use
    private_keys: Vec<StaticSecret>,
    /// Symmetric encryption key and nonce, if decrypted successfully from header
    encrypt_parameters: Option<(Key, [u8; NONCE_SIZE])>,
    /// `FailSafeReader` consideration for tag on decryption -- `FailSafeReader` only
    failsafe_mode: FailSafeReaderDecryptionMode,
}

impl EncryptionReaderConfig {
    pub fn load_persistent(
        &mut self,
        config: &EncryptionPersistentConfig,
    ) -> Result<(), ConfigError> {
        if self.private_keys.is_empty() {
            return Err(ConfigError::PrivateKeyNotSet);
        }
        for private_key in &self.private_keys {
            if let Ok(Some(key)) = retrieve_key(&config.multi_recipient, private_key) {
                self.encrypt_parameters = Some((key, config.nonce));
                break;
            }
        }

        if self.encrypt_parameters.is_none() {
            return Err(ConfigError::PrivateKeyNotFound);
        }
        Ok(())
    }
}

impl ArchiveReaderConfig {
    /// Set private key to use
    pub fn add_private_keys(&mut self, keys: &[StaticSecret]) -> &mut Self {
        self.encrypt.private_keys.extend_from_slice(keys);
        self
    }

    /// Retrieve key and nonce used for encryption
    pub const fn get_encrypt_parameters(&self) -> Option<(Key, [u8; NONCE_SIZE])> {
        self.encrypt.encrypt_parameters
    }

    /// Set the `FailSafeReader` decryption mode to return only authenticated data (default)
    pub const fn failsafe_return_only_authenticated_data(&mut self) -> &mut Self {
        self.encrypt.failsafe_mode = FailSafeReaderDecryptionMode::OnlyAuthenticatedData;
        self
    }

    /// Set the `FailSafeReader` decryption mode to return all data, even if not authenticated
    pub const fn failsafe_return_data_even_unauthenticated(&mut self) -> &mut Self {
        self.encrypt.failsafe_mode = FailSafeReaderDecryptionMode::DataEvenUnauthenticated;
        self
    }
}

// ---------- Writer ----------

pub struct EncryptionLayerWriter<'a, W: 'a + InnerWriterTrait> {
    inner: InnerWriterType<'a, W>,
    cipher: AesGcm256,
    /// Symmetric encryption Key
    key: Key,
    /// Symmetric encryption nonce prefix, see `build_nonce`
    nonce_prefix: [u8; NONCE_SIZE],
    current_chunk_offset: u64,
    current_ctr: u32,
}

impl<'a, W: 'a + InnerWriterTrait> EncryptionLayerWriter<'a, W> {
    pub fn new(inner: InnerWriterType<'a, W>, config: &EncryptionConfig) -> Result<Self, Error> {
        Ok(Self {
            inner,
            key: config.key,
            nonce_prefix: config.nonce,
            cipher: AesGcm256::new(&config.key, &build_nonce(config.nonce, 0), b"")?,
            current_chunk_offset: 0,
            current_ctr: 0,
        })
    }

    fn renew_cipher(&mut self) -> Result<Tag, Error> {
        // Prepare a new cipher
        self.current_ctr += 1;
        self.current_chunk_offset = 0;
        let cipher = AesGcm256::new(
            &self.key,
            &build_nonce(self.nonce_prefix, self.current_ctr),
            b"",
        )?;
        let old_cipher = std::mem::replace(&mut self.cipher, cipher);
        Ok(old_cipher.into_tag())
    }
}

impl<'a, W: 'a + InnerWriterTrait> LayerWriter<'a, W> for EncryptionLayerWriter<'a, W> {
    fn into_inner(self) -> Option<InnerWriterType<'a, W>> {
        Some(self.inner)
    }

    fn into_raw(self: Box<Self>) -> W {
        self.inner.into_raw()
    }

    fn finalize(&mut self) -> Result<(), Error> {
        // Write the tag of the current chunk
        let tag = self.renew_cipher()?;
        self.inner.write_all(&tag)?;

        // Recursive call
        self.inner.finalize()
    }
}

impl<W: InnerWriterTrait> Write for EncryptionLayerWriter<'_, W> {
    #[allow(clippy::comparison_chain)]
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        if self.current_chunk_offset > CHUNK_SIZE {
            // Should never happen
            return Err(
                Error::WrongWriterState("[EncryptWriter] Chunk too big".to_string()).into(),
            );
        } else if self.current_chunk_offset == CHUNK_SIZE {
            // Prepare a new cipher
            let tag = self.renew_cipher()?;
            // Write the previous chunk tag
            self.inner.write_all(&tag)?;
        }

        // StreamingCipher is working in place, so we use a temporary buffer
        let size = std::cmp::min(
            std::cmp::min(CIPHER_BUF_SIZE, buf.len() as u64),
            CHUNK_SIZE - self.current_chunk_offset,
        );
        let mut buf_tmp = Vec::with_capacity(usize::try_from(size).map_err(|_| {
            io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
        })?);
        let buf_src = BufReader::new(buf);
        io::copy(&mut buf_src.take(size), &mut buf_tmp)?;
        self.cipher.encrypt(&mut buf_tmp);
        self.inner.write_all(&buf_tmp)?;
        self.current_chunk_offset += size;
        usize::try_from(size)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed"))
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

// ---------- Reader ----------

// In the case of stream cipher, encrypting is the same that decrypting. Here, we
// keep the struct separated for any possible future difference

/// This struct permits code reuse on layer read between "normal" read and "failsafe" read
struct EncryptionLayerInternal<T: ?Sized> {
    inner: Box<T>,
    cipher: AesGcm256,
    key: Key,
    nonce: [u8; NONCE_SIZE],
    chunk_cache: Cursor<Vec<u8>>,
    current_chunk_number: u32,
}

impl<T: ?Sized> EncryptionLayerInternal<T> {
    pub fn new(inner: Box<T>, config: &EncryptionReaderConfig) -> Result<Self, Error> {
        match config.encrypt_parameters {
            Some((key, nonce)) => Ok(Self {
                inner,
                cipher: AesGcm256::new(&key, &build_nonce(nonce, 0), b"")?,
                key,
                nonce,
                chunk_cache: Cursor::new(Vec::with_capacity(usize::try_from(CHUNK_SIZE).map_err(
                    |_| io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed"),
                )?)),
                current_chunk_number: 0,
            }),
            None => Err(Error::PrivateKeyNeeded),
        }
    }
}

impl<T: ?Sized + Read> EncryptionLayerInternal<T> {
    /// Load the `self.current_chunk_number` chunk in cache
    /// Assume the inner layer is in the correct position
    fn load_in_cache(&mut self) -> Result<Option<()>, Error> {
        self.cipher = AesGcm256::new(
            &self.key,
            &build_nonce(self.nonce, self.current_chunk_number),
            b"",
        )?;

        // Clear current, now useless, allocated memory
        self.chunk_cache.get_mut().clear();

        // Load the current encrypted chunk and the corresponding tag in memory
        let mut data_and_tag = Vec::with_capacity(
            usize::try_from(CHUNK_SIZE).map_err(|_| {
                io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
            })? + TAG_LENGTH,
        );
        let data_and_tag_read = (&mut self.inner)
            .take(CHUNK_SIZE + TAG_LENGTH as u64)
            .read_to_end(&mut data_and_tag)?;
        // If the inner is at the end of the stream, we cannot read any
        // additional byte -> we must stop
        if data_and_tag_read == 0 {
            return Ok(None);
        }

        // If it is the last block, we may have read less than `CHUNK_SIZE +
        // TAG_LENGTH` bytes. But the `TAG_LENGTH` last bytes are always the tag
        // bytes -> extract it
        let mut tag = [0u8; TAG_LENGTH];
        tag.copy_from_slice(&data_and_tag[data_and_tag_read - TAG_LENGTH..]);
        data_and_tag.resize(data_and_tag_read - TAG_LENGTH, 0);
        let mut data = data_and_tag;

        // Decrypt and verify the current chunk
        let expected_tag = self.cipher.decrypt(data.as_mut_slice());
        if expected_tag.ct_eq(&tag).unwrap_u8() == 1 {
            self.chunk_cache = Cursor::new(data);
            Ok(Some(()))
        } else {
            Err(Error::AuthenticatedDecryptionWrongTag)
        }
    }

    /// Load in cache the decrypted data, without checking the authentication tag
    ///
    /// Assumption:
    /// - the inner layer is at the start of a CHUNK
    fn load_in_cache_unauthenticated(&mut self) -> Result<Option<()>, Error> {
        self.cipher = AesGcm256::new(
            &self.key,
            &build_nonce(self.nonce, self.current_chunk_number),
            b"",
        )?;

        // Clear current, now useless, allocated memory
        self.chunk_cache.get_mut().clear();

        // Load the current encrypted chunk in memory
        let mut data = Vec::with_capacity(usize::try_from(CHUNK_SIZE).map_err(|_| {
            io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
        })?);
        let data_read = (&mut self.inner).take(CHUNK_SIZE).read_to_end(&mut data)?;
        // If the inner is at the end of the stream, we cannot read any
        // additional byte -> we must stop
        if data_read == 0 {
            return Ok(None);
        }

        // Consume the tag without reading it
        io::copy(
            &mut (&mut self.inner).take(TAG_LENGTH as u64),
            &mut io::sink(),
        )?;

        // Decrypt the current chunk
        self.cipher.decrypt_unauthenticated(data.as_mut_slice());
        self.chunk_cache = Cursor::new(data);
        Ok(Some(()))
    }

    /// Internal `Read::read` but returning a mla `Error`
    ///
    /// This method check the tag of each decrypted block
    fn read_internal(&mut self, buf: &mut [u8]) -> Result<usize, Error> {
        let cache_to_consume = CHUNK_SIZE - self.chunk_cache.position();
        if cache_to_consume == 0 {
            // Cache totally consumed, renew it
            self.current_chunk_number += 1;
            if self.load_in_cache()?.is_none() {
                // No more byte in the inner layer
                return Ok(0);
            }
            return self.read_internal(buf);
        }
        // Consume at most the bytes leaving in the cache, to detect the renewal need
        let size = std::cmp::min(
            usize::try_from(cache_to_consume).map_err(|_| {
                io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
            })?,
            buf.len(),
        );
        self.chunk_cache
            .read(&mut buf[..size])
            .map_err(std::convert::Into::into)
    }

    /// Internal `Read::read` but returning a mla `Error`
    /// /!\ This method does not check the tag of each decrypted block
    fn read_internal_unauthenticated(&mut self, buf: &mut [u8]) -> Result<usize, Error> {
        let cache_to_consume = CHUNK_SIZE - self.chunk_cache.position();
        if cache_to_consume == 0 {
            // Cache totally consumed, renew it
            self.current_chunk_number += 1;
            if self.load_in_cache_unauthenticated()?.is_none() {
                // No more byte in the inner layer
                return Ok(0);
            }
            return self.read_internal_unauthenticated(buf);
        }
        // Consume at most the bytes leaving in the cache, to detect the renewal need
        let size = std::cmp::min(
            usize::try_from(cache_to_consume).map_err(|_| {
                io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
            })?,
            buf.len(),
        );
        self.chunk_cache
            .read(&mut buf[..size])
            .map_err(std::convert::Into::into)
    }
}

impl<R: Read + ?Sized> Read for EncryptionLayerInternal<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.read_internal(buf).map_err(std::convert::Into::into)
    }
}

impl<R: Read + Seek + ?Sized> Seek for EncryptionLayerInternal<R> {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        // `pos` is the position without considering tags
        match pos {
            SeekFrom::Start(pos) => {
                let tag_position = no_tag_position_to_tag_position(pos);
                let chunk_number = tag_position / CHUNK_TAG_SIZE;
                let pos_chunk_start = chunk_number * CHUNK_TAG_SIZE;
                let pos_in_chunk = tag_position % CHUNK_TAG_SIZE;

                // Seek the inner layer at the beginning of the chunk
                self.inner.seek(SeekFrom::Start(pos_chunk_start))?;

                // Load and move into the cache
                self.current_chunk_number = u32::try_from(chunk_number).map_err(|_| {
                    io::Error::new(io::ErrorKind::InvalidInput, "Chunk number out of range")
                })?;
                self.load_in_cache()?;
                self.chunk_cache.seek(SeekFrom::Start(pos_in_chunk))?;
                Ok(pos)
            }
            SeekFrom::Current(value) => {
                // Inner layer is at the start of the next chunk. The last chunk
                // may not be CHUNK_SIZE long.
                let current_inner = tag_position_to_no_tag_position(self.inner.seek(pos)?);
                let current_inner_chunk = {
                    let chunk_nb = current_inner / CHUNK_SIZE;
                    if chunk_nb == 0 {
                        // Only one chunk, witch is not CHUNK_SIZE long
                        0
                    } else {
                        chunk_nb - 1
                    }
                };
                let current = current_inner_chunk * CHUNK_SIZE + self.chunk_cache.position();
                if value == 0 {
                    // Optimization
                    Ok(current)
                } else {
                    self.seek(SeekFrom::Start(
                        u64::try_from(i64::try_from(current).unwrap() + value).map_err(|_| {
                            io::Error::new(io::ErrorKind::InvalidInput, "Seek overflow")
                        })?,
                    ))
                }
            }
            SeekFrom::End(pos) => {
                if pos > 0 {
                    // Seeking past the end is unsupported
                    return Err(Error::EndOfStream.into());
                }

                // The last chunk always have a TAG at its end, and might not be
                // CHUNK_SIZE longtry_ we need to remove the TAG size while
                // converting from tag-aware position to tag-unaware position
                let end_inner_pos = self.inner.seek(SeekFrom::End(0))?;
                let cur_chunk = end_inner_pos / CHUNK_TAG_SIZE;
                let cur_chunk_pos = end_inner_pos % CHUNK_TAG_SIZE;
                let end_pos = cur_chunk * CHUNK_SIZE + cur_chunk_pos - TAG_LENGTH as u64;
                let pos_adjusted = i64::try_from(end_pos)
                    .map_err(|_| {
                        io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed")
                    })?
                    .checked_add(pos)
                    .ok_or_else(|| {
                        io::Error::new(io::ErrorKind::InvalidInput, "Addition overflow")
                    })?;
                self.seek(SeekFrom::Start(u64::try_from(pos_adjusted).map_err(
                    |_| io::Error::new(io::ErrorKind::InvalidInput, "Integer conversion failed"),
                )?))
            }
        }
    }
}

pub struct EncryptionLayerReader<'a, R: Read + Seek>(
    EncryptionLayerInternal<dyn 'a + LayerReader<'a, R>>,
);

impl<'a, R: Read + Seek> EncryptionLayerReader<'a, R> {
    pub fn new(
        inner: Box<dyn 'a + LayerReader<'a, R>>,
        config: &EncryptionReaderConfig,
    ) -> Result<Self, Error> {
        Ok(EncryptionLayerReader(EncryptionLayerInternal::new(
            inner, config,
        )?))
    }
}

impl<'a, R: 'a + InnerReaderTrait> LayerReader<'a, R> for EncryptionLayerReader<'a, R> {
    fn into_inner(self) -> Option<Box<dyn 'a + LayerReader<'a, R>>> {
        Some(self.0.inner)
    }

    fn into_raw(self: Box<Self>) -> R {
        self.0.inner.into_raw()
    }

    fn initialize(&mut self) -> Result<(), Error> {
        // Recursive call
        self.0.inner.initialize()?;

        // Load the current buffer in cache
        self.rewind()?;
        Ok(())
    }
}

impl<'a, R: 'a + Read + Seek> Read for EncryptionLayerReader<'a, R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.0.read(buf)
    }
}

// Returns how many chunk are present at position `position`
const CHUNK_TAG_SIZE: u64 = CHUNK_SIZE + TAG_LENGTH as u64;

const fn no_tag_position_to_tag_position(position: u64) -> u64 {
    let cur_chunk = position / CHUNK_SIZE;
    let cur_chunk_pos = position % CHUNK_SIZE;
    cur_chunk * CHUNK_TAG_SIZE + cur_chunk_pos
}

fn tag_position_to_no_tag_position(position: u64) -> u64 {
    // Assume the position is not inside a tag. If so, round to the end of the
    // current chunk
    let cur_chunk = position / CHUNK_TAG_SIZE;
    let cur_chunk_pos = position % CHUNK_TAG_SIZE;
    cur_chunk * CHUNK_SIZE + std::cmp::min(cur_chunk_pos, CHUNK_SIZE)
}

impl<'a, R: 'a + Read + Seek> Seek for EncryptionLayerReader<'a, R> {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        self.0.seek(pos)
    }
}

// ---------- Fail-Safe Reader ----------

pub struct EncryptionLayerFailSafeReader<'a, R: Read> {
    internal: EncryptionLayerInternal<dyn 'a + LayerFailSafeReader<'a, R>>,
    decryption_mode: FailSafeReaderDecryptionMode,
}

impl<'a, R: Read> EncryptionLayerFailSafeReader<'a, R> {
    pub fn new(
        inner: Box<dyn 'a + LayerFailSafeReader<'a, R>>,
        config: &EncryptionReaderConfig,
    ) -> Result<Self, Error> {
        let mut layer = Self {
            internal: EncryptionLayerInternal::new(inner, config)?,
            decryption_mode: config.failsafe_mode,
        };
        layer.internal.load_in_cache_unauthenticated()?;
        Ok(layer)
    }
}

impl<'a, R: 'a + Read> LayerFailSafeReader<'a, R> for EncryptionLayerFailSafeReader<'a, R> {
    fn into_inner(self) -> Option<Box<dyn 'a + LayerFailSafeReader<'a, R>>> {
        Some(self.internal.inner)
    }

    fn into_raw(self: Box<Self>) -> R {
        self.internal.inner.into_raw()
    }
}

impl<R: Read> Read for EncryptionLayerFailSafeReader<'_, R> {
    /// Behavior changes depending on config.FailSafeReaderDecryptionMode
    /// - `OnlyAuthenticatedData`: only authenticated data is returned
    /// - `DataEvenUnauthenticated`: all data is returned, even if not authenticated
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        match self.decryption_mode {
            FailSafeReaderDecryptionMode::OnlyAuthenticatedData => {
                // catch AuthenticatedDecryptionWrongTag to gracefully stop the reading
                match self.internal.read_internal(buf) {
                    Ok(size) => Ok(size),
                    Err(Error::AuthenticatedDecryptionWrongTag) => Ok(0),
                    Err(e) => Err(e.into()),
                }
            }
            FailSafeReaderDecryptionMode::DataEvenUnauthenticated => {
                Ok(self.internal.read_internal_unauthenticated(buf)?)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use rand::SeedableRng;
    use rand::distr::{Alphanumeric, Distribution};
    use std::io::{Cursor, Read, Seek, SeekFrom, Write};

    use crate::crypto::aesgcm::KEY_SIZE;
    use crate::layers::raw::{RawLayerFailSafeReader, RawLayerReader, RawLayerWriter};

    static FAKE_FILE: [u8; 26] = *b"abcdefghijklmnopqrstuvwxyz";
    static KEY: Key = [2u8; KEY_SIZE];
    static NONCE: [u8; NONCE_SIZE] = [3u8; NONCE_SIZE];

    fn encrypt_write(file: Vec<u8>) -> Vec<u8> {
        // Instantiate a EncryptionLayerWriter and fill it with FAKE_FILE
        let mut encrypt_w = Box::new(
            EncryptionLayerWriter::new(
                Box::new(RawLayerWriter::new(file)),
                &EncryptionConfig {
                    ecc_keys: Vec::new(),
                    key: KEY,
                    nonce: NONCE,
                },
            )
            .unwrap(),
        );
        encrypt_w.write_all(&FAKE_FILE[..21]).unwrap();
        encrypt_w.write_all(&FAKE_FILE[21..]).unwrap();
        encrypt_w.finalize().unwrap();

        let out = encrypt_w.into_raw();
        assert_eq!(out.len(), FAKE_FILE.len() + TAG_LENGTH);
        assert_ne!(out[..FAKE_FILE.len()], FAKE_FILE);
        out
    }

    #[test]
    fn encrypt_layer() {
        let file = Vec::new();
        let out = encrypt_write(file);

        let buf = Cursor::new(out.as_slice());
        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r =
            EncryptionLayerReader::new(Box::new(RawLayerReader::new(buf)), &config).unwrap();
        encrypt_r.initialize().unwrap();
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        assert_eq!(output, FAKE_FILE);
    }

    #[test]
    fn encrypt_failsafe_layer() {
        let file = Vec::new();
        let out = encrypt_write(file);

        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r = EncryptionLayerFailSafeReader::new(
            Box::new(RawLayerFailSafeReader::new(out.as_slice())),
            &config,
        )
        .unwrap();
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        // Extra output expected, due to the ignored tag in the last chunk
        assert_eq!(output[..FAKE_FILE.len()], FAKE_FILE);
    }

    #[test]
    fn encrypt_failsafe_truncated() {
        let file = Vec::new();
        let out = encrypt_write(file);

        // Truncate at the middle
        let stop = out.len() / 2;

        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r = EncryptionLayerFailSafeReader::new(
            Box::new(RawLayerFailSafeReader::new(&out[..stop])),
            &config,
        )
        .unwrap();
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();

        // Thanks to the encrypt layer construction, we can recover `stop` bytes
        assert_eq!(output.as_slice(), &FAKE_FILE[..stop]);
    }

    #[test]
    fn failsafe_auth_vs_unauth() {
        // Prepare inner layer (to be encrypted)
        let file = Vec::new();
        let mut encrypt_w = Box::new(
            EncryptionLayerWriter::new(
                Box::new(RawLayerWriter::new(file)),
                &EncryptionConfig {
                    ecc_keys: Vec::new(),
                    key: KEY,
                    nonce: NONCE,
                },
            )
            .unwrap(),
        );

        // Write a 2*CHUNK_SIZE + 128 bytes stream
        let length =
            usize::try_from(2 * CHUNK_SIZE + 128).expect("Failed to convert CHUNK_SIZE to usize");
        let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);
        let data: Vec<u8> = Alphanumeric.sample_iter(&mut rng).take(length).collect();
        encrypt_w.write_all(&data).unwrap();
        encrypt_w.finalize().unwrap();
        let out = encrypt_w.into_raw();
        assert_eq!(out.len(), length + 3 * TAG_LENGTH);

        // data: [CHUNK1 (CHUNK_SIZE)][TAG1][CHUNK2 (CHUNK_SIZE)][TAG2][CHUNK3 (128)][TAG3]
        // Truncate to remove the last tag
        let trunc = &out[..out.len() - TAG_LENGTH];

        // Failsafe read with tag checking
        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r = EncryptionLayerFailSafeReader::new(
            Box::new(RawLayerFailSafeReader::new(trunc)),
            &config,
        )
        .unwrap();
        let mut output_authent = Vec::new();
        encrypt_r.read_to_end(&mut output_authent).unwrap();

        // We should have correctly read 2*CHUNK_SIZE inner data, the last 128 bytes being unauthenticated
        assert_eq!(
            output_authent.len(),
            2 * usize::try_from(CHUNK_SIZE).unwrap()
        );
        assert_eq!(output_authent, data[..output_authent.len()]);

        // Failsafe read without tag checking
        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::DataEvenUnauthenticated,
        };
        let mut encrypt_r = EncryptionLayerFailSafeReader::new(
            Box::new(RawLayerFailSafeReader::new(trunc)),
            &config,
        )
        .unwrap();
        let mut output_unauthent = Vec::new();
        encrypt_r.read_to_end(&mut output_unauthent).unwrap();

        // We should have correctly read 2*CHUNK_SIZE + 128 bytes, the last 128 bytes being unauthenticated
        assert_eq!(output_unauthent.len(), length);
        assert_eq!(output_unauthent, data);
    }

    #[test]
    fn seek_encrypt() {
        // First, encrypt a dummy file
        let file = Vec::new();
        let out = encrypt_write(file);

        // Normal decryption
        let buf = Cursor::new(out.as_slice());
        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r =
            EncryptionLayerReader::new(Box::new(RawLayerReader::new(buf)), &config).unwrap();
        encrypt_r.initialize().unwrap();
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        assert_eq!(output, FAKE_FILE);

        // Seek and decrypt twice the same thing
        let pos = encrypt_r.stream_position().unwrap();
        // test the current position retrievial
        assert_eq!(pos, tag_position_to_no_tag_position(FAKE_FILE.len() as u64));
        // decrypt twice the same thing, with an offset
        let pos = encrypt_r.seek(SeekFrom::Start(5)).unwrap();
        assert_eq!(pos, 5);
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        println!("{output:?}");
        assert_eq!(output.as_slice(), &FAKE_FILE[5..]);
    }

    #[test]
    fn encrypt_op_chunk_size() {
        // Operate near the chunk size

        // Instantiate a EncryptionLayerWriter and fill it with at least CHUNK_SIZE data
        let file = Vec::new();
        let mut encrypt_w = Box::new(
            EncryptionLayerWriter::new(
                Box::new(RawLayerWriter::new(file)),
                &EncryptionConfig {
                    ecc_keys: Vec::new(),
                    key: KEY,
                    nonce: NONCE,
                },
            )
            .unwrap(),
        );
        let length =
            usize::try_from(CHUNK_SIZE * 2).expect("Failed to convert CHUNK_SIZE to usize");
        let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);
        let data: Vec<u8> = Alphanumeric.sample_iter(&mut rng).take(length).collect();
        encrypt_w.write_all(&data).unwrap();
        encrypt_w.finalize().unwrap();

        let out = encrypt_w.into_raw();
        assert_eq!(out.len(), length + 2 * TAG_LENGTH);
        assert_ne!(&out[..length], data.as_slice());

        // Normal decryption
        let buf = Cursor::new(out.as_slice());
        let config = EncryptionReaderConfig {
            private_keys: Vec::new(),
            encrypt_parameters: Some((KEY, NONCE)),
            failsafe_mode: FailSafeReaderDecryptionMode::OnlyAuthenticatedData,
        };
        let mut encrypt_r =
            EncryptionLayerReader::new(Box::new(RawLayerReader::new(buf)), &config).unwrap();
        encrypt_r.initialize().unwrap();
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        assert_eq!(output, data);

        // Seek and decrypt twice the same thing
        let pos = encrypt_r.seek(SeekFrom::Start(CHUNK_SIZE)).unwrap();
        assert_eq!(pos, CHUNK_SIZE);
        let mut output = Vec::new();
        encrypt_r.read_to_end(&mut output).unwrap();
        assert_eq!(
            output.as_slice(),
            &data[usize::try_from(CHUNK_SIZE).unwrap()..]
        );
    }
}
