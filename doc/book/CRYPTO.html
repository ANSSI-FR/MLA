<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crypto - Multi Layer Archive</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Multi Layer Archive</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cryptography-in-mla"><a class="header" href="#cryptography-in-mla">Cryptography in MLA</a></h1>
<p>MLA uses cryptographic primitives essentially for the purpose of the <code>Encrypt</code> layer.</p>
<p>This document introduces the primitives used, arguments for the choice made and some security considerations.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High-level overview</a></h2>
<h3 id="objectives"><a class="header" href="#objectives">Objectives</a></h3>
<p>The purpose of the <code>Encrypt</code> layer is to provide confidentiality and data integrity of the inner layer.</p>
<p>These objectives are obtained using:</p>
<ul>
<li>Authenticated encryption</li>
<li>Asymmetric cryptography, for several recipients</li>
</ul>
<p>This layer <strong>does not provide signature</strong>.</p>
<h3 id="general-design-guidelines"><a class="header" href="#general-design-guidelines">General design guidelines</a></h3>
<ol>
<li>The size and the initial computation time used for the encryption needs are not a big issue, if kept reasonable. Indeed, in the author understanding, MLA archives are usually several MB long and the computation time is primarily spent in compression/decompression and encryption/decryption of the data</li>
</ol>
<p>As a result, some optimization have not been performed -- which help keeping an hopefully auditable and conservative design.</p>
<ol start="2">
<li>
<p>Only one encryption method and key type is available, to avoid confusion and potential corner cases errors</p>
</li>
<li>
<p>When possible, use audited code and test vectors</p>
</li>
</ol>
<h3 id="main-bricks-encryption"><a class="header" href="#main-bricks-encryption">Main bricks: Encryption</a></h3>
<p>The data is encrypted using AES-256-GCM, an AEAD algorithm.
To offer a <em>seekable</em> layer, data is encrypted using chunks of 128KB each, except for the last one. These encrypted chunks are all present with their associated tag. Tags are checked during decryption before returning data to the upper layer.</p>
<p>To prevent truncation attacks, another chunk is added at the end corresponding to the encryption of the ASCII string "FINALBLOCK" with "FINALAAD" as additional authenticated data. Any usage of the archive must check correct decryption (including tag verification) of this last block.</p>
<p>The key, the base nonce and the nonce derivation for each data chunk are computed following HPKE (RFC 9180) <sup class="footnote-reference" id="fr-hpke-1"><a href="#footnote-hpke">1</a></sup>.
HPKE is parameterized with:</p>
<ul>
<li>Mode: "Base" (no PSK, no sender authentication)</li>
<li>KDF: HKDF-SHA512</li>
<li>AEAD: AES-256-GCM</li>
<li>KEM: Multi-Recipient Hybrid KEM, a custom KEM described later in this document</li>
</ul>
<p>Thus, only one cryptography suite is available for now. If this setting ends up broken by cryptanalysis, we will move users onward to the next MLA version, using appropriate cryptography. Therefore, MLA lacks cryptography agility which is an encouraged property regarding post-quantum cryptography by ANSSI <sup class="footnote-reference" id="fr-frsuggest-1"><a href="#footnote-frsuggest">2</a></sup>. Still, HPKE improves this aspect of MLA <sup class="footnote-reference" id="fr-hpke-2"><a href="#footnote-hpke">1</a></sup>.</p>
<p>Full details are available below.</p>
<p>Additionally, "key commitment" is included using a method described in <sup class="footnote-reference" id="fr-keycommit-1"><a href="#footnote-keycommit">3</a></sup> and detailed in <sup class="footnote-reference" id="fr-issuekeycommit-1"><a href="#footnote-issuekeycommit">4</a></sup>.</p>
<h3 id="main-bricks-asymmetric-encryption"><a class="header" href="#main-bricks-asymmetric-encryption">Main bricks: Asymmetric encryption</a></h3>
<p>Since the format <code>v2</code>, the <code>Encrypt</code> layer is using post-quantum cryptography (PQC) through an hybrid approach, to avoid "Harvest now, decrypt later" attacks.</p>
<p>The algorithms used are:</p>
<ul>
<li>Curve 25519 for pre-quantum cryptography, using DHKEM (RFC 9180) <sup class="footnote-reference" id="fr-hpke-3"><a href="#footnote-hpke">1</a></sup></li>
<li>FIPS 203<sup class="footnote-reference" id="fr-fips203-1"><a href="#footnote-fips203">5</a></sup> (CRYSTALS Kyber) MLKEM-1024 for post-quantum cryptography</li>
</ul>
<p>The two keys are mixed together (see below) in a manner keeping the IND-CCA2 properties of the two algorithms.</p>
<p>Sending to multiple recipients is achieved using a two-step process:</p>
<ol>
<li>For each recipient, a per-recipient Hybrid KEM is done, leading to a per-recipient shared secret</li>
<li>These per-recipient shared secret are derived through HPKE to obtain a key and a nonce</li>
<li>These per-recipient key and nonce are used to decrypt a secret shared by all recipients</li>
</ol>
<p>This final secret is the one later used as an input to the encryption layer.
The whole process can be viewed as a KEM encapsulation for multiple recipients.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>The following sections describe the whole process for data encryption and seed derivation.
They are meant to ease the understanding of the code and MLA format re-implementation.</p>
<p>The interested reader could also look at the Rust implementation in this repository for more details.
The implementation also includes tests (including some test vectors) and comments.</p>
<h3 id="asymmetric-encryption---per-recipient-kem"><a class="header" href="#asymmetric-encryption---per-recipient-kem">Asymmetric encryption - Per-recipient KEM</a></h3>
<h4 id="notations"><a class="header" href="#notations">Notations</a></h4>
<ul>
<li>$pk_{ecc}^i$, $sk_{ecc}^i$, $pk_{mlkem}^i$ and $sk_{mlkem}^i$: respectively the curve 25519 public key and secret key, and the MLKEM-1024 (FIPS 203 <sup class="footnote-reference" id="fr-fips203-2"><a href="#footnote-fips203">5</a></sup>) encapsulating key and decapsulating key</li>
<li>$\textrm{DHKEM.Encapsulate}$ and $\textrm{DHKEM.Decapsulate}$: key encapsulation methods on the curve 25519, as defined in RFC 9180, section 4 <sup class="footnote-reference" id="fr-hpke-4"><a href="#footnote-hpke">1</a></sup></li>
<li>$\textrm{MLKEM.Encapsulate}$ and $\textrm{MLKEM.Decapsulate}$: key encapsulation methods on MLKEM-1024, as defined in FIPS 203 <sup class="footnote-reference" id="fr-fips203-3"><a href="#footnote-fips203">5</a></sup></li>
<li>$ss_{recipients}$: a 32-bytes secret, produced by a cryptographic RNG. Informally, this is the secret shared among recipients, encapsulated separately for each recipient</li>
<li>$\textrm{KeySchedule}_{recipient}$: <code>KeySchedule</code> function from RFC 9180 <sup class="footnote-reference" id="fr-hpke-5"><a href="#footnote-hpke">1</a></sup>, instanciated with:
<ul>
<li>Mode: "Base"</li>
<li>KDF: HKDF-SHA-512</li>
<li>AEAD: AES-256-GCM</li>
<li>KEM: a custom KEM ID, numbered 0x1120</li>
</ul>
</li>
<li>$\textrm{Encrypt}_{AES\ 256\ GCM}$: AES-256-GCM encryption, returning the encrypted data concatened with the associated tag</li>
<li>$\textrm{Decrypt}_{AES\ 256\ GCM}$ AES-256-GCM decryption, returning the decrypted data after verifying the tag</li>
<li>$\textrm{Serialize}$ and $\textrm{Deserialize}$: respectively produce a byte string encoding the data in argument, and produce the data from the byte string in argument</li>
</ul>
<h4 id="process"><a class="header" href="#process">Process</a></h4>
<p>To encrypt to a target recipient $i$, knowing $pk_{ecc}^i$ and $pk_{mlkem}^i$:</p>
<ol>
<li>Compute shared secrets and ciphertexts for both KEM:</li>
</ol>
<pre><code class="language-math">\begin{align}
(ss_{ecc}^i, ct_{ecc}^i) &amp;= \textrm{DHKEM.Encapsulate}(pk_{ecc}^i) \\
(ss_{mlkem}^i, ct_{mlkem}^i) &amp;= \textrm{MLKEM.Encapsulate}(pk_{mlkem}^i)
\end{align}
</code></pre>
<ol start="2">
<li>Combine the shared secrets (implemented in <code>mla::crypto::hybrid::combine</code>):</li>
</ol>
<pre><code class="language-python">def combine(ss1, ss2, ct1, ct2):
    uniformly_random_ss1 = HKDF-SHA512-Extract(
        salt=0,
        ikm=ss1
    )
    key = HKDF(
        salt=uniformly_random_ss1,
        ikm=ss2,
        info=ct1 . ct2
    )
    return key
</code></pre>
<pre><code class="language-math">ss_{recipient}^i = \textrm{combine}(ss_{ecc}^i, ss_{mlkem}^i, ct_{ecc}^i, ct_{mlkem}^i)
</code></pre>
<ol start="3">
<li>Wrap the recipients' shared secret:</li>
</ol>
<pre><code class="language-math">\begin{align}
(key^i, nonce^i) &amp;= \textrm{KeySchedule}_{recipient}(
        shared\_secret=ss_{recipient}^i,
    \textrm{info}=\mathtt{"MLA\ Recipient"}
)\\
ct_{wrap}^i &amp;= \textrm{Encrypt}_{AES\ 256\ GCM}(\textrm{key}=key^i, \textrm{nonce}=nonce^i, \textrm{data}=ss_{recipients})\\
ct_{recipient}^i &amp;= \textrm{Serialize}(ct_{wrap}^i, ct_{ecc}^i, ct_{mlkem}^i)
\end{align}
</code></pre>
<p>Informally, this process can be viewed as a per-recipient KEM taking a shared secret $ss_{recipients}$, the recipient public key (made of the elliptic curve and the PQC public keys) and returning a ciphertext $ct_{recipient}^i$.</p>
<hr />
<p>To obtain the shared secret from $ct_{recipient}^i$ for a recipient $i$ knowing $sk_{ecc}^i$ and $sk_{mlkem}^i$:</p>
<ol>
<li>Compute the recipient's shared secret:</li>
</ol>
<pre><code class="language-math">\begin{align}
(ct_{wrap}^i, ct_{ecc}^i, ct_{mlkem}^i) &amp;= \textrm{Deserialize}(ct_{recipient}^i)\\
ss_{ecc}^i &amp;= \textrm{DHKEM.Decapsulate}(sk_{ecc}^i, ct_{ecc}^i) \\
ss_{mlkem}^i &amp;= \textrm{MLKEM.Decapsulate}(sk_{mlkem}^i, ct_{mlkem}^i)\\
ss_{recipient}^i &amp;= \textrm{combine}(ss_{ecc}^i, ss_{mlkem}^i, ct_{ecc}^i, ct_{mlkem}^i)
\end{align}
</code></pre>
<ol start="2">
<li>Try to decrypt the secret shared among recipients:</li>
</ol>
<pre><code class="language-math">\begin{align}
(key^i, nonce^i) &amp;= \textrm{KeySchedule}_{recipient}(
        shared\_secret=ss_{recipient}^i,
    \textrm{info}=\mathtt{"MLA\ Recipient"}
)\\
ss_{recipients} &amp;= \textrm{Decrypt}_{AES\ 256\ GCM}(\textrm{key}=key^i, \textrm{nonce}=nonce^i, \textrm{data}=ct_{wrap}^i)
\end{align}
</code></pre>
<p>If the decryption is a success, returns $ss_{recipients}$. Otherwise, returns an error.</p>
<h4 id="arguments"><a class="header" href="#arguments">Arguments</a></h4>
<ul>
<li>Using HPKE (RFC 9180 <sup class="footnote-reference" id="fr-hpke-6"><a href="#footnote-hpke">1</a></sup>) for both elliptic curve encryption (DHKEM) and post-quantum encryption (MLKEM) offers several benefits<sup class="footnote-reference" id="fr-issuehpke-1"><a href="#footnote-issuehpke">6</a></sup>:
<ul>
<li>Easier re-implementation of the format MLA, thanks to the availability of HPKE in cryptographic libraries</li>
<li>An existing formal analysis <sup class="footnote-reference" id="fr-hpkeanalysis-1"><a href="#footnote-hpkeanalysis">7</a></sup></li>
<li>Easier code and security auditing, thanks to the use of known bricks</li>
<li>Availability of test vectors in the RFC, making the implementation more reliable</li>
<li>If signature is added to MLA in a future version, it could also be integrated using HPKE</li>
</ul>
</li>
<li>To the knowledge of the author, no HPKE algorithm has been standardized for quantum hybridation, hence the custom algorithm</li>
<li>FIPS 203 is used as, at the time of writing:
<ul>
<li>It is the only KEM algorithm standardized by the NIST <sup class="footnote-reference" id="fr-nist-1"><a href="#footnote-nist">8</a></sup></li>
<li>It is in line with the French suggestions <sup class="footnote-reference" id="fr-frsuggest-2"><a href="#footnote-frsuggest">2</a></sup> for PQ cryptography</li>
</ul>
</li>
<li>The MLKEM-1024 mode is used for stronger security, and to limit consequence of future advances [^mlkemcon1]<sup class="footnote-reference" id="fr-mlkemcon2-1"><a href="#footnote-mlkemcon2">9</a></sup>. This is also the choice of other industry standards [^signal]<sup class="footnote-reference" id="fr-imessage-1"><a href="#footnote-imessage">10</a></sup></li>
<li>The shared secret from the two-KEM is produced using a "Nested Dual-PRF Combiner", proved in <sup class="footnote-reference" id="fr-dualnest-1"><a href="#footnote-dualnest">11</a></sup> (3.3):
<ul>
<li>The use of concatenation scheme <strong>including ciphertexts</strong> keeps IND-CCA2 if one of the two underlying scheme is IND-CCA2, as proved in <sup class="footnote-reference" id="fr-combinearg1-1"><a href="#footnote-combinearg1">12</a></sup> and explained in <sup class="footnote-reference" id="fr-combinearg4-1"><a href="#footnote-combinearg4">13</a></sup></li>
<li>TLS <sup class="footnote-reference" id="fr-combinearg2-1"><a href="#footnote-combinearg2">14</a></sup> uses a similar scheme, and IKE <sup class="footnote-reference" id="fr-combinearg3-1"><a href="#footnote-combinearg3">15</a></sup> also uses a concatenation scheme</li>
<li>This kind of scheme follows ANSSI recommendations <sup class="footnote-reference" id="fr-frsuggest-3"><a href="#footnote-frsuggest">2</a></sup></li>
<li>HKDF can be considered as a Dual-PRF if both inputs are uniformly random <sup class="footnote-reference" id="fr-combinearg7-1"><a href="#footnote-combinearg7">16</a></sup>. In MLA, the <code>combine</code> method is called with a shared secret from ML-KEM, and the resulting ECC key derivation -- both are uniformly random</li>
<li>To avoid potential mistake in the future, or a mis-reuse of this method, the "Nested Dual-PRF Combiner" is used instead of the "Dual-PRF Combiner" (also from <sup class="footnote-reference" id="fr-dualnest-2"><a href="#footnote-dualnest">11</a></sup>). Indeed, this combiner force the "salt" part of HKDF to be uniformly random using an additional PRF use, ensuring the following HKDF is indeed a Dual-PRF</li>
</ul>
</li>
</ul>
<h3 id="asymmetric-encryption---multi-recipient-hybrid-kem"><a class="header" href="#asymmetric-encryption---multi-recipient-hybrid-kem">Asymmetric encryption - Multi-Recipient Hybrid KEM</a></h3>
<h4 id="intuition"><a class="header" href="#intuition">Intuition</a></h4>
<p>KEM, such as the one described above, returns a fresh and distinct secret for each recipient.</p>
<p>To obtain a "meta-KEM", working for multi-recipient, the strategy is the use of per-recipient KEM to encrypt a common secret.</p>
<p>This whole process can then be viewed as a KEM for multi-recipient, taking in input a list of public keys and returning a shared secret and a ciphertext made of the concatenation of each per-recipient ciphertext.</p>
<p>To avoid marking which per-recipient ciphertext correspond to which recipient public key, the decapsulation process "brute-force" each ciphertext for a given decapsulation key. If the decryption works (with the associated tag), the shared secret is returned.</p>
<p>Key commitment, to avoid rather unlikely mismatch, is further ensured inside the <code>Encrypt</code> layer (see below).</p>
<h4 id="process-1"><a class="header" href="#process-1">Process</a></h4>
<p>The "Per-recipient KEM" process described above is noted:</p>
<ul>
<li>$\mathrm{PerRecipientKEM.Encapsulate}$, taking a couple of public key ($pk_{ecc}^i$ and $pk_{mlkem}^i$), a shared secret $ss_{recipients}$ and returning a recipient ciphertext $ct_{recipient}^i$</li>
<li>$\mathrm{PerRecipientKEM.Decapsulate}$, taking a couple of private key ($sk_{ecc}^i$ and $sk_{mlkem}^i$), a ciphertext $ct_{recipients}$ and returning either a shared secret $ss_{recipients}$ if the recipient $i$ is a legitimate recipient (if the AEAD decryption works), or an error otherwise</li>
</ul>
<p>$\mathrm{CSPRNG(n)}$ is a cryptographically secured RNG producing a n-bytes secret.</p>
<p>To encapsulate to a list of recipient $[(pk_{ecc}^0, pk_{mlkem}^0), ..., (pk_{ecc}^{n-1}, pk_{mlkem}^{n-1})]$:</p>
<pre><code class="language-math">\begin{align*}
\mathtt{def\ } &amp; \mathrm{HybridKEM.Encapsulate}([(pk_{ecc}^0, pk_{mlkem}^0), ..., (pk_{ecc}^{n-1}, pk_{mlkem}^{n-1})])\\
&amp; ss_{recipients} = \mathrm{CSPRNG(32)}\\
&amp; ct_{recipient}^0 = \mathrm{PerRecipientKEM}((pk_{ecc}^0,pk_{mlkem}^0),ss_{recipients})\\
&amp; \dots\\
&amp; ct_{recipient}^{n-1} = \mathrm{PerRecipientKEM}((pk_{ecc}^{n-1},pk_{mlkem}^{n-1}),ss_{recipients})\\
&amp; ct_{recipients} = \mathrm{Serialize}(ct_{recipient}^0, \dots, ct_{recipient}^{n-1})\\
&amp; \mathtt{return}\ ss_{recipients},\ ct_{recipients}
\end{align*}
</code></pre>
<hr />
<p>To decapsulate from a ciphertext $ct_{recipients}$, knowing a recipient private key $(sk_{ecc}^i,sk_{mlkem}^i)$:</p>
<p>$\mathtt{def\ } \mathrm{HybridKEM.Decapsulate}((sk_{ecc}^i,sk_{mlkem}^i), ct_{recipients})$<br />
$\hspace{1cm}\mathtt{foreach\ } ct_k \mathtt{\ in\ } \mathrm{Deserialize}(ct_{recipients})$<br />
$\hspace{2cm}\mathtt{try:}$<br />
$\hspace{3cm}ss_{recipients} = \mathrm{PerRecipientKEM.Decapsulate}((sk_{ecc}^i,sk_{mlkem}^i), ct_k)$<br />
$\hspace{2cm}\mathtt{success:}$<br />
$\hspace{3cm}\mathtt{return}\ ss_{recipients}$<br />
$\hspace{2cm}\mathtt{error:}$<br />
$\hspace{3cm}\mathtt{continue}$<br />
$\hspace{1cm}\mathtt{throw\ KeyNotFoundError}$</p>
<h4 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h4>
<ul>
<li>The shared secret is cryptographically generated, so it can later be used as a shared secret in HPKE encryption</li>
<li>This secret is unique per archive, as it is generated on archive creation. Even "converting" or "repairing" an archive in <code>mlar</code> CLI will force a newly fresh secret. It is a new secret as there is no edit feature implemented, even if it is doable. Hence, a new random symetric key is used to encrypt its content while "converting" or "repairing" an archive.</li>
<li>Even if the AEAD decryption worked for an non legitimate recipient, for instance following an intentional manipulation, the shared secret obtained will later be checked using Key commitment before decrypting actual data (see below)</li>
<li>Optimization would have been possible here, such as sharing a common ephemeral key for the DHKEM. But the size gain is not worth enough regarding the ciphertext size of MLKEM and would move the implementation away from the DHKEM in RFC 9180</li>
</ul>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<h4 id="notation"><a class="header" href="#notation">Notation</a></h4>
<p>The "Multi-Recipient Hybrid KEM" process described above is noted:</p>
<ul>
<li>$\mathrm{MultiRecipientHybridKEM.Encapsulate}$, taking a list of public keys $[(pk_{ecc}^0, pk_{mlkem}^0), ..., (pk_{ecc}^{n-1}, pk_{mlkem}^{n-1})]$ and returing a shared secret $ss_{recipients}$ and a ciphertext $ct_{recipients}$</li>
<li>$\mathrm{MultiRecipientHybridKEM.Decapsulate}$, taking a couple of private keys ($sk_{ecc}^i$ and $sk_{mlkem}^i$), a ciphertext $ct_{recipients}$ and returning either a shared secret $ss_{recipients}$ if the recipient $i$ is a legitimate recipient (if the AEAD decryption works), or an error otherwise</li>
</ul>
<p><code>KeyCommitmentChain</code> is defined as the array of 64-bytes: <code>-KEY COMMITMENT--KEY COMMITMENT--KEY COMMITMENT--KEY COMMITMENT-</code>.</p>
<p>$\textrm{KeySchedule}_{hybrid}$: <code>KeySchedule</code> function from RFC 9180 <sup class="footnote-reference" id="fr-hpke-7"><a href="#footnote-hpke">1</a></sup>, instanciated with:</p>
<ul>
<li>Mode: "Base"</li>
<li>KDF: HKDF-SHA-512</li>
<li>AEAD: AES-256-GCM</li>
<li>KEM: a custom KEM ID, numbered 0x1020</li>
</ul>
<p>$\mathrm{ComputeNonce}$: function from RFC 9180 <sup class="footnote-reference" id="fr-hpke-8"><a href="#footnote-hpke">1</a></sup>.</p>
<h4 id="process-2"><a class="header" href="#process-2">Process</a></h4>
<p>To encrypt n-bytes <code>data</code> to a list of public keys $[(pk_{ecc}^0, pk_{mlkem}^0), ..., (pk_{ecc}^{n-1}, pk_{mlkem}^{n-1})]$:</p>
<ol>
<li>Compute a shared secret and the corresponding ciphertext:</li>
</ol>
<pre><code class="language-math">ss_{recipients},\ ct_{recipients} = \mathrm{MultiRecipientHybridKEM.Encapsulate}([(pk_{ecc}^0, pk_{mlkem}^0), ..., (pk_{ecc}^{n-1}, pk_{mlkem}^{n-1})])
</code></pre>
<ol start="2">
<li>Derive the key and base nonce using HPKE</li>
</ol>
<pre><code class="language-math">(key, base\_nonce) = \textrm{KeySchedule}_{hybrid}(
        shared\_secret=ss_{recipients},
    \textrm{info}=\mathtt{"MLA\ Encrypt\ Layer"}
)
</code></pre>
<ol start="3">
<li>Ensure key-commitment</li>
</ol>
<pre><code class="language-math">\begin{align*}
keycommit&amp; = \textrm{Encrypt}_{AES\ 256\ GCM}(\\
    &amp;\textrm{key}=key,\\
    &amp;\textrm{nonce}=\mathrm{ComputeNonce}(base\_nonce, 0),\\
    &amp;\textrm{data}=\textrm{KeyCommitmentChain}\\
)&amp;
\end{align*}
</code></pre>
<ol start="4">
<li>For each 128KB $chunk_j$ of data:</li>
</ol>
<pre><code class="language-math">\begin{align*}
enc_j&amp; = \textrm{Encrypt}_{AES\ 256\ GCM}(\\
    &amp;\textrm{key}=key,\\
    &amp;\textrm{nonce}=\mathrm{ComputeNonce}(base\_nonce, j + 1),\\
    &amp;\textrm{data}=chunk_j\\
)&amp;
\end{align*}
</code></pre>
<p>Note: $j$ starts at 0. $j+1$ is used because the sequence numbered 0 has already been used by the Key commitment.</p>
<ol start="5">
<li>
<p>When the layer is finalized, the last chunk of data (with a length lower than or equals to 128KB) is encrypted the same way</p>
</li>
<li>
<p>Finally, a final chunk with sequence number $n+1$ (where $n$ is the number of data chunks) and special content and additional authenticated data is appended:</p>
</li>
</ol>
<pre><code class="language-math">\begin{align*}
final\_chunk&amp; = \textrm{Encrypt}_{AES\ 256\ GCM}(\\
    &amp;\textrm{key}=key,\\
    &amp;\textrm{nonce}=\mathrm{ComputeNonce}(base\_nonce, n + 1),\\
    &amp;\textrm{data}="FINALBLOCK"\\
    &amp;\textrm{aad}="FINALAAD"\\
)&amp;
\end{align*}
</code></pre>
<p>The resulting layer is composed of:</p>
<ul>
<li>header: $ct_{recipients}$</li>
<li>data: $keycommit \ .\ enc_0\ . \dots\ enc_n \ .$ $<code>final\_chunk</code>$</li>
</ul>
<p>Special care must be taken not to reuse a sequence number in implementations as this would be catastrophic given GCM properties. For $n$ chunks of data:</p>
<ul>
<li>sequence 0: key commitment</li>
<li>sequence 1 to $n$: data</li>
<li>sequence $n+1$: $<code>final\_chunk</code>$ with only the 10 bytes "FINALBLOCK" as content</li>
</ul>
<hr />
<p>To decrypt the data at position $pos$:</p>
<ol>
<li>Once for the whole session, get the cryptographic materials</li>
</ol>
<pre><code class="language-math">\begin{align}
ss_{recipients} &amp;= \mathrm{MultiRecipientHybridKEM.Decapsulate}((sk_{ecc}^i, sk_{mlkem}^i), ct_{recipients})\\
(key, base\_nonce) &amp;= \textrm{KeySchedule}_{hybrid}(
        shared\_secret=ss_{recipients},
    \textrm{info}=\mathtt{"MLA\ Encrypt\ Layer"}
)
\end{align}
</code></pre>
<ol start="2">
<li>Once for the whole session, check the key commitment</li>
</ol>
<pre><code class="language-math">\begin{align*}
commit&amp; = \textrm{Decrypt}_{AES\ 256\ GCM}(\\
    &amp;\textrm{key}=key,\\
    &amp;\textrm{nonce}=\mathrm{ComputeNonce}(base\_nonce, 0),\\
    &amp;\textrm{data}=keycommit\\
)&amp;
\end{align*}
</code></pre>
<pre><code class="language-math">\mathtt{assert\ }commit = \textrm{KeyCommitmentChain}
</code></pre>
<ol start="3">
<li>Retrieve the encrypted chunk of data</li>
</ol>
<pre><code class="language-math">\begin{align}
start &amp;= pos - \mathtt{sizeof}(keycommit)\\
j &amp;= pos \div 128KiB\\
\end{align}
</code></pre>
<p>Where $\div$ is the Euclidian division.</p>
<p>Then:</p>
<pre><code class="language-math">\begin{align*}
chunk_j&amp; = \textrm{Decrypt}_{AES\ 256\ GCM}(\\
    &amp;\textrm{key}=key,\\
    &amp;\textrm{nonce}=\mathrm{ComputeNonce}(base\_nonce, j + 1),\\
    &amp;\textrm{data}=enc_j\\
)&amp;
\end{align*}
</code></pre>
<h4 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h4>
<ul>
<li>Key commitment is always checked before returning clear-text data to the caller</li>
<li>AEAD tag of a chunk is always checked before returning the corresponding clear-text data to the caller</li>
<li>Arguments for HPKE use are very similar to the ones mentioned above. In particular, this is a standardized approach with existing analysis</li>
<li>As there is two kind of custom KEM used ("Per-recipient KEM" and "Hybrid KEM"), two distinct KEM ID are used. In addition, two distinct MLA specific <code>info</code> are used to bind this derivation to MLA</li>
<li>As described in <sup class="footnote-reference" id="fr-keycommit-2"><a href="#footnote-keycommit">3</a></sup> and <sup class="footnote-reference" id="fr-keycommit2-1"><a href="#footnote-keycommit2">17</a></sup>, AES in GCM mode does not ensure "key commitment". This property is added in the layer using the "padding fix" scheme from <sup class="footnote-reference" id="fr-keycommit-3"><a href="#footnote-keycommit">3</a></sup> with the recommended 512-bits size for a 256-bits security</li>
<li>Key commitment is mainly used to ensure that two recipients will decrypt to the same plaintext if given the same ciphertext, i.e. an attacker modifying the header of an archive cannot provide two distinct plaintext to two distinct recipient</li>
<li>AES-GCM is used as an industry standard AEAD
<ul>
<li>the base nonce, and therefore each nonce used, are unique per archive because they are generated from the archive-specific shared secret, limiting the nonce-reuse risk to standard acceptability <sup class="footnote-reference" id="fr-hpke-9"><a href="#footnote-hpke">1</a></sup></li>
<li>no more than $2^{64}$ chunks will be produced, as the sequence's type used in MLA implementation is a <code>u64</code> checked for overflow. As this is a widely accepted limit of AES-GCM, this value is also within the range provided by <sup class="footnote-reference" id="fr-hpke-10"><a href="#footnote-hpke">1</a></sup></li>
<li>the tag size is 128-bits (standard one), avoiding attacks described in <sup class="footnote-reference" id="fr-weaknessgcm-1"><a href="#footnote-weaknessgcm">18</a></sup></li>
<li>128KiB is lower than the maximum plaintext length for a single message in AES-GCM (64 GiB)<sup class="footnote-reference" id="fr-weaknessgcm-2"><a href="#footnote-weaknessgcm">18</a></sup></li>
</ul>
</li>
</ul>
<h3 id="seed-derivation"><a class="header" href="#seed-derivation">Seed derivation</a></h3>
<p>The asymmetric encryption in MLA, particularly the KEMs, provides deterministic API.</p>
<p>These API are usually fed with cryptographically generated data, except for the regression test and the "seed derivation" feature in <code>mlar</code> CLI.</p>
<p>This feature is meant to provide a way for client to implement:</p>
<ul>
<li>A derivation tree</li>
<li>Keep the root secret in a safe place, and be able to find back the derived secrets</li>
</ul>
<p>The derivation scheme is based on the same ideas than <code>mla::crypto::hybrid::combine</code>:</p>
<ol>
<li>A dual-PRF (HKDF-Extract with a uniform random salt <sup class="footnote-reference" id="fr-combinearg7-2"><a href="#footnote-combinearg7">16</a></sup>) to extract entropy from the private key</li>
<li>HKDF-Expand to derive along the given path component</li>
</ol>
<p>From a private key ($sk_{ecc}^i$ and $sk_{mlkem}^i$), the secret is derived from the path component $pc$ through:</p>
<pre><code class="language-math">\begin{align}
ecc\_rnd &amp;= \mathrm{HKDF.Extract_{SHA512}}(\mathrm{salt}=0, \mathrm{ikm}=sk_{ecc}^i)\\
seed &amp;= \mathrm{HKDF_{SHA512}}(
    \mathrm{salt}=ecc\_rnd,
    \mathrm{ikm}=sk_{mlkem}^i,
    \mathrm{info}=\mathtt{"PATH\ DERIVATION"}\ .\ pc
)
\end{align}
</code></pre>
<p>To derive a key using a <code>seed</code>, a <code>ChaChaRng</code> is used.
If a <code>seed</code> is provided, the <code>ChaChaRng</code> is seeded with the first 32-bytes of $\mathrm{SHA512}(seed)$. Otherwise, the <code>ChaChaRng::from_entropy</code> is used, wrapping OS Cryptographic RNG sources.</p>
<p>The CSRNG is then provided to MLA deterministic APIs.</p>
<h2 id="implementation-specificities"><a class="header" href="#implementation-specificities">Implementation specificities</a></h2>
<h3 id="external-dependencies"><a class="header" href="#external-dependencies">External dependencies</a></h3>
<p>Some of the external cryptographic libraries have been reviewed:</p>
<ul>
<li>RustCrypto AES-GCM, reviewed by NCC Group <sup class="footnote-reference" id="fr-reviewncc-1"><a href="#footnote-reviewncc">19</a></sup></li>
<li>Dalek cryptography library, reviewed by Quarkslab <sup class="footnote-reference" id="fr-reviewqb-1"><a href="#footnote-reviewqb">20</a></sup></li>
<li><code>rust-hpke</code> library, reviewed in version 0.8 by CloudFlare <sup class="footnote-reference" id="fr-reviewcloudflare-1"><a href="#footnote-reviewcloudflare">21</a></sup></li>
</ul>
<p>In addition to the review, <code>rust-hpke</code> is mainly based on <code>RustCrypto</code>, avoiding the need for additional newer dependencies.</p>
<p>The MLKEM implementation used is the one of <code>RustCrypto</code>, as MLA already depends on this project and the code quality and auditability are, in the author understanding, rather good.</p>
<p>The generation uses <code>OsRng</code> from crate <code>rand</code>, that uses <code>getrandom()</code> from crate <code>getrandom</code>. <code>getrandom</code> provides implementations for many systems, listed <a href="https://docs.rs/getrandom/0.1.14/getrandom/">here</a>.
On Linux it uses the <code>getrandom()</code> syscall and falls back on <code>/dev/urandom</code>.
On Windows it uses the <code>RtlGenRandom</code> API (available since Windows XP/Windows Server 2003).</p>
<p>In order to be "better safe than sorry", a <code>ChaChaRng</code> is seeded from the bytes generated by <code>OsRng</code> in order to build a CSPRNG(Cryptographically Secure PseudoRandom Number Generator). This <code>ChaChaRng</code> provides the actual bytes used in keys and nonces generations.</p>
<p>The authors decided to use elliptic curve over RSA, because:</p>
<ul>
<li>No ready-for-production Rust-based libraries have been found at the date of writing</li>
<li>A security-audited Rust library already exists for Curve25519</li>
<li>Curve25519 is widely used and <a href="https://safecurves.cr.yp.to/">respects several criteria</a></li>
<li>Common arguments, such as the ones of <a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">Trail of bits</a></li>
</ul>
<p>AES-GCM is used because it is one of the most commonly used AEAD algorithms and using one avoids a whole class of attacks. In addition, it lets us rely on hardware acceleration (like AES-NI) to keep reasonable performance.</p>
<h3 id="aes-gcm-re-implementation"><a class="header" href="#aes-gcm-re-implementation">AES-GCM re-implementation</a></h3>
<p>While the AES and GHash bricks come from RustCrypto, the GCM mode for AES-256 has been re-implemented in MLA.</p>
<p>Indeed, the repair mode must be able to only partially decrypt a data chunk, and decide whether the associated tag must be verified or not. This API is not provided by the RustCrypto project, for very understandable reasons.</p>
<p>To ensure the implementation follows the standard, it is tested against AES-256-GCM test vectors in MLA regression tests.</p>
<h3 id="hpke-key-schedule-re-implementation"><a class="header" href="#hpke-key-schedule-re-implementation">HPKE Key Schedule re-implementation</a></h3>
<p>For several reasons described in the code, but mainly due to the availability of API, the possibility to add custom KEM ID and the relative few lines needed for re-implementation, the $\mathrm{KeySchedule}$ method has been re-implemented in MLA.</p>
<p>It still use some bricks from <code>rust-hpke</code>, as the KDF, $\mathrm{LabeledExtract}$ and $\mathrm{LabeledExpand}$. It is tested against RFC 9180 <sup class="footnote-reference" id="fr-hpke-11"><a href="#footnote-hpke">1</a></sup> test vectors in MLA regression tests.</p>
<h3 id="mlkem-implementation-without-a-review"><a class="header" href="#mlkem-implementation-without-a-review">MLKEM implementation without a review</a></h3>
<p>Thanks to the hybrid approach, a flawed implementation of MLKEM would have limited consequences. It satisfies ANSSI guidelines for the transition first phase to PQC hybridization <sup class="footnote-reference" id="fr-frsuggest-4"><a href="#footnote-frsuggest">2</a></sup>. For this reason, MLA is eligible for a security visa evaluation.</p>
<p>For now, it is therefore accepted by the author (as a trade-off) to use a MLKEM implementation without existing review to bring as soon as possible a reasonable protection against "Harvest now, decrypt later" attacks.</p>
<p>If a reviewed implementation with acceptable dependency emerges in the future, it can be easily swapped in MLA. Thus, MLA would also satisfy the requirements to get a security visa evaluation in the second and third phases of these guidelines by including its PQC implementation.</p>
<h2 id="security-consideration"><a class="header" href="#security-consideration">Security consideration</a></h2>
<h3 id="absence-of-signature"><a class="header" href="#absence-of-signature">Absence of signature</a></h3>
<p>As there is no signature for now in MLA, an attacker knowing the recipient public key can always create a custom archive with arbitrary data.</p>
<p>For this reason, several known attacks are considered acceptable, such as:</p>
<ul>
<li>The bit indicating if the <code>Encrypt</code> layer is present is not protected in integrity</li>
</ul>
<p>An attacker can remove it, making the reader treating the archive as if encryption was absent. <em>The reader is responsible of checking for encryption bit if it was expected in the first place</em>.</p>
<p>For instance, the <code>mlar</code> CLI will refuse to open an archive without the <code>Encrypt</code> bit unless <code>--accept-unencrypted</code> is provided on the command line.</p>
<ul>
<li>An attacker with the ability to modify a real archive in transit can replace what the reader will be able to read with arbitrary data</li>
</ul>
<p>To perform this attack, the attacker will have to either remove the <code>Encrypt</code> bit or modify the key used for decryption with one she has.
The remaining encrypted data will then act as random values.</p>
<p>Still, the attacker could expect to gain enough privilege, like arbitrary code execution in the process, during the archive read. One can then try to reuse the provided key to decrypt, then act on the real data.</p>
<p>Limiting this attack is beyond the scope of this document. It mainly involves the security features of Rust, reviewed implementation, testing &amp; fuzzing, zeroizing secrets when possible <sup class="footnote-reference" id="fr-issuezeroize-1"><a href="#footnote-issuezeroize">22</a></sup>, etc.</p>
<ul>
<li>An attacker can truncate an archive and hope for repair</li>
</ul>
<p>This attack is based on a trade-off: should the <code>SafeReader</code> try to get as many bytes as possible, or should it return only data that have been authenticated?</p>
<p>The choice has been made to report the decision to the user of the library<sup class="footnote-reference" id="fr-issueallowunauth-1"><a href="#footnote-issueallowunauth">23</a></sup>.</p>
<h3 id="other-properties"><a class="header" href="#other-properties">Other properties</a></h3>
<ul>
<li>Plaintext length</li>
</ul>
<p>The <code>Encrypt</code> layer does not hide the plaintext length.</p>
<p>Usually, this layer is used with the <code>Compress</code> layer. If an attacker knows the original file size, he might learn information about the original data entropy.</p>
<ul>
<li>Hidden recipient list</li>
</ul>
<p>Only the owner of a recipient's private key can determine that they are a recipient of the archive. In other words, while the recipient list remains private, the total number of recipients is still visible.</p>
<p>This is an intentional privacy feature.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-hpke">
<p><a href="https://datatracker.ietf.org/doc/rfc9180/">Hybrid Public Key Encryption, RFC 9180</a> <a href="#fr-hpke-1">↩</a> <a href="#fr-hpke-2">↩2</a> <a href="#fr-hpke-3">↩3</a> <a href="#fr-hpke-4">↩4</a> <a href="#fr-hpke-5">↩5</a> <a href="#fr-hpke-6">↩6</a> <a href="#fr-hpke-7">↩7</a> <a href="#fr-hpke-8">↩8</a> <a href="#fr-hpke-9">↩9</a> <a href="#fr-hpke-10">↩10</a> <a href="#fr-hpke-11">↩11</a></p>
</li>
<li id="footnote-frsuggest">
<p>https://cyber.gouv.fr/en/publications/follow-position-paper-post-quantum-cryptography <a href="#fr-frsuggest-1">↩</a> <a href="#fr-frsuggest-2">↩2</a> <a href="#fr-frsuggest-3">↩3</a> <a href="#fr-frsuggest-4">↩4</a></p>
</li>
<li id="footnote-keycommit">
<p><a href="https://www.usenix.org/conference/usenixsecurity22/presentation/albertini">"How to Abuse and Fix Authenticated Encryption Without Key Commitment", Usenix'22</a> <a href="#fr-keycommit-1">↩</a> <a href="#fr-keycommit-2">↩2</a> <a href="#fr-keycommit-3">↩3</a></p>
</li>
<li id="footnote-issuekeycommit">
<p>https://github.com/ANSSI-FR/MLA/issues/206 <a href="#fr-issuekeycommit-1">↩</a></p>
</li>
<li id="footnote-fips203">
<p><a href="https://csrc.nist.gov/pubs/fips/203/ipd">FIPS 203 - MLKEM Standard</a> <a href="#fr-fips203-1">↩</a> <a href="#fr-fips203-2">↩2</a> <a href="#fr-fips203-3">↩3</a></p>
</li>
<li id="footnote-issuehpke">
<p>https://github.com/ANSSI-FR/MLA/issues/211 <a href="#fr-issuehpke-1">↩</a></p>
</li>
<li id="footnote-hpkeanalysis">
<p>https://eprint.iacr.org/2020/1499.pdf <a href="#fr-hpkeanalysis-1">↩</a></p>
</li>
<li id="footnote-nist">
<p>https://csrc.nist.gov/News/2022/pqc-candidates-to-be-standardized-and-round-4 <a href="#fr-nist-1">↩</a></p>
</li>
<li id="footnote-mlkemcon2">
<p>https://kyberslash.cr.yp.to/ <a href="#fr-mlkemcon2-1">↩</a></p>
</li>
<li id="footnote-imessage">
<p>https://security.apple.com/blog/imessage-pq3/ <a href="#fr-imessage-1">↩</a></p>
</li>
<li id="footnote-dualnest">
<p>https://eprint.iacr.org/2018/903.pdf <a href="#fr-dualnest-1">↩</a> <a href="#fr-dualnest-2">↩2</a></p>
</li>
<li id="footnote-combinearg1">
<p>https://eprint.iacr.org/2018/024 <a href="#fr-combinearg1-1">↩</a></p>
</li>
<li id="footnote-combinearg4">
<p>https://eprint.iacr.org/2024/039 <a href="#fr-combinearg4-1">↩</a></p>
</li>
<li id="footnote-combinearg2">
<p>https://datatracker.ietf.org/doc/draft-ietf-tls-hybrid-design/ <a href="#fr-combinearg2-1">↩</a></p>
</li>
<li id="footnote-combinearg3">
<p>https://datatracker.ietf.org/doc/html/rfc9370 <a href="#fr-combinearg3-1">↩</a></p>
</li>
<li id="footnote-combinearg7">
<p>https://eprint.iacr.org/2023/861 <a href="#fr-combinearg7-1">↩</a> <a href="#fr-combinearg7-2">↩2</a></p>
</li>
<li id="footnote-keycommit2">
<p>https://eprint.iacr.org/2019/016.pdf <a href="#fr-keycommit2-1">↩</a></p>
</li>
<li id="footnote-weaknessgcm">
<p><a href="https://csrc.nist.gov/csrc/media/projects/block-cipher-techniques/documents/bcm/comments/cwc-gcm/ferguson2.pdf">"Authentication weaknesses in GCM"</a> <a href="#fr-weaknessgcm-1">↩</a> <a href="#fr-weaknessgcm-2">↩2</a></p>
</li>
<li id="footnote-reviewncc">
<p>https://research.nccgroup.com/wp-content/uploads/2020/02/NCC_Group_MobileCoin_RustCrypto_AESGCM_ChaCha20Poly1305_Implementation_Review_2020-02-12_v1.0.pdf <a href="#fr-reviewncc-1">↩</a></p>
</li>
<li id="footnote-reviewqb">
<p>https://blog.quarkslab.com/security-audit-of-dalek-libraries.html <a href="#fr-reviewqb-1">↩</a></p>
</li>
<li id="footnote-reviewcloudflare">
<p>https://blog.cloudflare.com/using-hpke-to-encrypt-request-payloads/ <a href="#fr-reviewcloudflare-1">↩</a></p>
</li>
<li id="footnote-issuezeroize">
<p>https://github.com/ANSSI-FR/MLA/issues/46 <a href="#fr-issuezeroize-1">↩</a></p>
</li>
<li id="footnote-issueallowunauth">
<p>https://github.com/ANSSI-FR/MLA/issues/167 <a href="#fr-issueallowunauth-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ENTRY_NAME.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="KEY_DERIVATION.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ENTRY_NAME.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="KEY_DERIVATION.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
